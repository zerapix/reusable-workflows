# Creates a release; if you want to use this in other projects a better start is probably
# one of the py-merge-to-main-* workflows (which in turn can use this reusable workflow).
on:
  workflow_call:
    inputs:
      reusable-ref:
        type: string
        default: main
        description: Reusable workflow branch/tag/etc I am being called in.

      # *** Ignored Inputs ***
      # (here in case something tries to pass it in, workflow will still work).
      RUN_TESTS:
        required: false
        type: string
        description: _ ***CURRENTLY IGNORED** Python package we are versioning/deploying; only skips if string is set to 'false' (using string, as composite actions only use strings)
        default: 'true'

    outputs:
      created-release:
        description: "If final/tagged release was created or not."
        value: ${{ jobs.create-pre-or-release.outputs.created-release }}
concurrency: create-release
run-name: Create Release + Auto Deploy by @${{ github.actor }}

name: Create Release
jobs:
  create-release:
    runs-on: ubuntu-latest
    # If are already on a 'release' commit, we should skip this job.
    if: "!startsWith(github.event.head_commit.message, 'chore(release): ')"
    outputs:
      created-release-tag-name: ${{ steps.release.outputs.created-release-tag-name }}
    steps:

      - uses: zerapix/reusable-workflows/all-checkout@test
        with:
          # fetch-depth 0 will check out all the commits and tags needed for release-bumper
          fetch-depth: 0
          reusable-ref: ${{ inputs.reusable-ref }}
          zreleasebot_app_id: ${{ secrets.ZRELEASEBOT_APP_ID }}
          zreleasebot_private_key: ${{ secrets.ZRELEASEBOT_PRIVATE_KEY }}


      - uses: ./.reusable-workflows/py-setup-project
        with:
          GEMFURY_DEPLOY_TOKEN: ${{ secrets.GEMFURY_DEPLOY_TOKEN }}

      - uses: ./.reusable-workflows/py-create-release
        id: release
        with:
          GEMFURY_DEPLOY_TOKEN: ${{ secrets.GEMFURY_DEPLOY_TOKEN }}
          release-branch: ${{ inputs.release-branch }}

  # Create Separate Job, to distinguish release-creation from deployment
  # (release could have succeeded but deployment fail, can easily re-run deployment without running create-release again)
  deploy-release:
    needs: create-release
    runs-on: ubuntu-latest
    steps:
      - name: Release Thunk
        run: echo "Deployed Tag ${{ needs.create-release.outputs.created-release-tag-name }}"
      - name: Trigger Workflow
        uses: actions/github-script@v6
        with:
          # Run a new workflow job, using originating repo's standard `deployment.yml` via workflow_dispatch
          script: |
            github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'deployment-auto.yml',
              ref: 'refs/tags/${{ needs.create-release.outputs.created-release-tag-name }}',
            })
